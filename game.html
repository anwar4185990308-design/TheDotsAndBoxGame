<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TITAN_OS: COMBAT_CORE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&family=Rajdhani:wght@500;700&family=Fira+Code:wght@400;700&display=swap');

        :root {
            --bg: #050508;
            --red: #ff0055;
            --blue: #00f2ff;
            --gold: #ffcc00;
            --grid: #111;
        }

        body, html { 
            margin: 0; padding: 0; background: var(--bg); color: white; 
            font-family: 'Rajdhani', sans-serif; height: 100vh; overflow: hidden; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* --- UI OVERLAYS --- */
        .hud-top {
            position: absolute; top: 0; width: 100%; padding: 20px 40px;
            display: flex; justify-content: space-between; align-items: center;
            box-sizing: border-box; border-bottom: 1px solid #222; background: rgba(0,0,0,0.8);
            z-index: 100;
        }

        .pilot-tag { font-family: 'Orbitron'; color: var(--red); letter-spacing: 2px; }
        .match-stats { font-family: 'Fira Code'; font-size: 0.8rem; color: var(--blue); }

        /* --- GAME BOARD --- */
        #game-container {
            position: relative; padding: 20px; background: rgba(255,255,255,0.02);
            border: 1px solid #222; box-shadow: 0 0 50px rgba(0,0,0,1);
        }

        canvas { cursor: crosshair; display: block; }

        /* --- TURN INDICATOR --- */
        .turn-display {
            margin-top: 20px; font-family: 'Orbitron'; font-size: 1.2rem;
            padding: 10px 30px; border: 1px solid #333; letter-spacing: 5px;
            transition: 0.3s;
        }
        .player-turn { color: var(--blue); border-color: var(--blue); text-shadow: 0 0 10px var(--blue); }
        .ai-turn { color: var(--red); border-color: var(--red); text-shadow: 0 0 10px var(--red); }

        /* --- MODALS --- */
        #result-overlay {
            display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 1000; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; backdrop-filter: blur(10px);
        }

        .result-box {
            padding: 60px; border: 2px solid var(--blue); background: #000;
            clip-path: polygon(0 20px, 20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
        }

        .result-box h1 { font-family: 'Orbitron'; font-size: 3rem; margin: 0; }
        .reward-text { color: var(--gold); font-family: 'Fira Code'; margin: 20px 0; font-size: 1.2rem; }

        .btn-action {
            margin-top: 30px; padding: 15px 40px; background: var(--red);
            color: white; border: none; font-family: 'Orbitron'; cursor: pointer;
            transition: 0.3s; font-weight: 900;
        }
        .btn-action:hover { transform: scale(1.1); box-shadow: 0 0 30px var(--red); }

    </style>
</head>
<body>

    <div class="hud-top">
        <div class="pilot-tag" id="pilot-name">PILOT: UNKNOWN</div>
        <div class="match-stats">
            SCORE: <span id="score-player" style="color:var(--blue)">0</span> 
            - VS - 
            <span id="score-ai" style="color:var(--red)">0</span>
        </div>
        <div style="font-family:'Orbitron'; color:var(--gold); cursor:pointer;" onclick="location.href='/'">ABORT_MISSION</div>
    </div>

    <div id="game-container">
        <canvas id="dotsCanvas"></canvas>
    </div>

    <div class="turn-display player-turn" id="turn-status">YOUR_TURN</div>

    <div id="result-overlay">
        <div class="result-box" id="result-box">
            <h1 id="res-title">MISSION_SUCCESS</h1>
            <div class="reward-text" id="res-reward">+50 XP | +10 CREDITS</div>
            <button class="btn-action" onclick="location.href='/'">RETURN_TO_HUB</button>
            <button class="btn-action" style="background:#222; margin-left:10px;" onclick="location.reload()">RE-ENGAGE</button>
        </div>
    </div>

    <script src="account.js"></script>
    <script>
        /**
         * COMBAT_CORE: DOTS & BOXES ENGINE
         */
        const canvas = document.getElementById('dotsCanvas');
        const ctx = canvas.getContext('2d');
        const user = sessionStorage.getItem('titan_user');
        const userData = JSON.parse(sessionStorage.getItem('titan_data')) || { level: 1, wins: 0, streak: 0, xp: 0 };

        document.getElementById('pilot-name').innerText = `PILOT: ${user.toUpperCase()}`;

        // Grid Configuration
        const ROWS = 5;
        const COLS = 5;
        const SPACING = 80;
        const OFFSET = 40;
        const DOT_RADIUS = 5;

        canvas.width = (COLS - 1) * SPACING + OFFSET * 2;
        canvas.height = (ROWS - 1) * SPACING + OFFSET * 2;

        let lines = []; // {p1, p2, owner}
        let boxes = []; // {r, c, owner}
        let playerTurn = true;
        let pScore = 0;
        let aiScore = 0;

        // Initialize Boxes
        for (let r = 0; r < ROWS - 1; r++) {
            for (let c = 0; c < COLS - 1; c++) {
                boxes.push({ r, c, owner: null });
            }
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Boxes (Filled)
            boxes.forEach(box => {
                if (box.owner) {
                    ctx.fillStyle = box.owner === 'P' ? 'rgba(0, 242, 255, 0.1)' : 'rgba(255, 0, 85, 0.1)';
                    ctx.fillRect(OFFSET + box.c * SPACING, OFFSET + box.r * SPACING, SPACING, SPACING);
                    ctx.font = "bold 20px Orbitron";
                    ctx.fillStyle = box.owner === 'P' ? varColor('--blue') : varColor('--red');
                    ctx.fillText(box.owner, OFFSET + box.c * SPACING + 30, OFFSET + box.r * SPACING + 45);
                }
            });

            // Draw Possible Lines (Ghost)
            ctx.strokeStyle = "#111";
            ctx.lineWidth = 2;
            for(let i=0; i<COLS; i++) {
                for(let j=0; j<ROWS; j++) {
                    // Vertical lines
                    if(j < ROWS-1) drawLine(i, j, i, j+1, "#111");
                    // Horizontal lines
                    if(i < COLS-1) drawLine(i, j, i+1, j, "#111");
                }
            }

            // Draw Active Lines
            lines.forEach(line => {
                drawLine(line.p1.x, line.p1.y, line.p2.x, line.p2.y, line.owner === 'P' ? varColor('--blue') : varColor('--red'), 4);
            });

            // Draw Dots
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    ctx.beginPath();
                    ctx.arc(OFFSET + c * SPACING, OFFSET + r * SPACING, DOT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = "#444";
                    ctx.fill();
                }
            }
        }

        function drawLine(x1, y1, x2, y2, color, width = 2) {
            ctx.beginPath();
            ctx.moveTo(OFFSET + x1 * SPACING, OFFSET + y1 * SPACING);
            ctx.lineTo(OFFSET + x2 * SPACING, OFFSET + y2 * SPACING);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }

        function varColor(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!playerTurn) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let bestLine = getNearestLine(mouseX, mouseY);
            if (bestLine && !isLineTaken(bestLine)) {
                makeMove(bestLine, 'P');
            }
        });

        function getNearestLine(mx, my) {
            let bestDist = 20;
            let line = null;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    // Check Horizontal
                    if (c < COLS - 1) {
                        let lx = OFFSET + c * SPACING + SPACING / 2;
                        let ly = OFFSET + r * SPACING;
                        let dist = Math.hypot(mx - lx, my - ly);
                        if (dist < bestDist) { bestDist = dist; line = { p1: { x: c, y: r }, p2: { x: c + 1, y: r } }; }
                    }
                    // Check Vertical
                    if (r < ROWS - 1) {
                        let lx = OFFSET + c * SPACING;
                        let ly = OFFSET + r * SPACING + SPACING / 2;
                        let dist = Math.hypot(mx - lx, my - ly);
                        if (dist < bestDist) { bestDist = dist; line = { p1: { x: c, y: r }, p2: { x: c, y: r + 1 } }; }
                    }
                }
            }
            return line;
        }

        function isLineTaken(l) {
            return lines.some(existing => 
                (existing.p1.x === l.p1.x && existing.p1.y === l.p1.y && existing.p2.x === l.p2.x && existing.p2.y === l.p2.y)
            );
        }

        function makeMove(line, owner) {
            lines.push({ ...line, owner });
            let boxesCompleted = checkBoxes(owner);
            
            drawBoard();
            updateScores();

            if (boxesCompleted === 0) {
                playerTurn = !playerTurn;
                document.getElementById('turn-status').innerText = playerTurn ? "YOUR_TURN" : "AI_THINKING...";
                document.getElementById('turn-status').className = `turn-display ${playerTurn ? 'player-turn' : 'ai-turn'}`;
                if (!playerTurn) setTimeout(aiMove, 600);
            } else {
                if(isGameOver()) endGame();
            }
        }

        function checkBoxes(owner) {
            let completed = 0;
            boxes.filter(b => !b.owner).forEach(box => {
                const top = lines.some(l => l.p1.y === box.r && l.p2.y === box.r && l.p1.x === box.c && l.p2.x === box.c + 1);
                const bottom = lines.some(l => l.p1.y === box.r + 1 && l.p2.y === box.r + 1 && l.p1.x === box.c && l.p2.x === box.c + 1);
                const left = lines.some(l => l.p1.x === box.c && l.p2.x === box.c && l.p1.y === box.r && l.p2.y === box.r + 1);
                const right = lines.some(l => l.p1.x === box.c + 1 && l.p2.x === box.c + 1 && l.p1.y === box.r && l.p2.y === box.r + 1);

                if (top && bottom && left && right) {
                    box.owner = owner;
                    completed++;
                    if (owner === 'P') pScore++; else aiScore++;
                }
            });
            return completed;
        }

        function aiMove() {
            if (isGameOver()) return;
            
            let availableLines = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (c < COLS - 1) {
                        let l = { p1: { x: c, y: r }, p2: { x: c + 1, y: r } };
                        if (!isLineTaken(l)) availableLines.push(l);
                    }
                    if (r < ROWS - 1) {
                        let l = { p1: { x: c, y: r }, p2: { x: c, y: r + 1 } };
                        if (!isLineTaken(l)) availableLines.push(l);
                    }
                }
            }

            if (availableLines.length > 0) {
                // Simple AI: Random Move
                const move = availableLines[Math.floor(Math.random() * availableLines.length)];
                makeMove(move, 'AI');
            }
        }

        function updateScores() {
            document.getElementById('score-player').innerText = pScore;
            document.getElementById('score-ai').innerText = aiScore;
        }

        function isGameOver() {
            return boxes.every(b => b.owner !== null);
        }

        async function endGame() {
            const overlay = document.getElementById('result-overlay');
            const title = document.getElementById('res-title');
            const reward = document.getElementById('res-reward');
            overlay.style.display = 'flex';

            if (pScore > aiScore) {
                title.innerText = "MISSION_SUCCESS";
                title.style.color = varColor('--blue');
                
                // Reward Logic
                let xpGain = 50;
                let coinGain = 20;

                userData.xp += xpGain;
                userData.wins += 1;
                userData.streak += 1;

                // Level Up Logic
                const nextLevelXP = 100 + (userData.level - 1) * 50;
                if (userData.xp >= nextLevelXP) {
                    userData.level++;
                    userData.xp = 0;
                    reward.innerText = `LEVEL_UP: RANK ${userData.level}! +${coinGain}â‚®`;
                } else {
                    reward.innerText = `+${xpGain} XP | +${coinGain} NEURAL_CREDITS`;
                }

                // Sync with MongoDB via server.js
                await AccountSystem.saveProgress(user, userData);
                
                // Sync Coins
                const currentCoinsRes = await fetch(`/get-coins/${user}`);
                const currentCoinsData = await currentCoinsRes.json();
                await AccountSystem.saveCoins(user, (currentCoinsData.coins || 0) + coinGain);

            } else {
                title.innerText = "LINK_CORRUPTED";
                title.style.color = varColor('--red');
                reward.innerText = "STREAK_TERMINATED. NO REWARDS ACQUIRED.";
                userData.streak = 0;
                await AccountSystem.saveProgress(user, userData);
            }
        }

        drawBoard();
    </script>
</body>
</html>
